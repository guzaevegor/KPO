Ключевое слово Auto в С и C++, переспособлены под разные цели. В С++ это синтаксический сахар. В С -
Время жизни и область видимости аналогичны auto-переменным 
По возможности переменной ставится в соответствие регистр. 
Время жизни от момента входа на выход из входа. (С точки зрения компилятора)
В автоматическом классе хранения переменные распалагаются в стеке, в регистровом(по возможности) - в регистрах общего назначения.
в наше время компиляторы умные, и если передать правильные значения, то может попытаться назначить register. У переменной расположенной в регистре не будет адреса. 
Переменные статического класса хранения размещаются в статической памяти.
(Т.е в секции/сегменте данных)
Могут быть:
-Локальные(объявлена внутри блока)
-Глобальные
В чем разница у статических и не статических?
Переменные статик существуют до конца завершения всей программы. Как глобальные переменные.
Но у статических ограничивается областью видимости локальных функций.

Область видимости глобальной переменной с классом хранения static - файл. Но есть нюансы
static - класс хранения по умолчанию для глобальных переменных.
Переменные с классом хранения static по умолчанию инициализируются нулевыми значениями. 

Внешний класс хранения 
Используется чтобы, сделать доступной в блоке переменную, определенную глобально.
		    использовать глобальные переменные, объявленные в разных файлах.

Ограничение: нельзя задавать начальное значение (инициализировать)
Прием для тестирования удачности реализации: Что если это сделают двое и более

Подытожим:
Только для локальных переменных:
auto
register
Для локальных и глобальных:
static
extern

Тема:
Структуры, объединения и перечисления
Структуры
Структура - совокупность переменных(возможно различных типов), сгруппированных под одним именем.
Объявление структурного типа имеет ту же область видимости, что и объявление переменных.(Блок, если не объявлен в блоке) или файл (если объявлен вне блока).
Обращение через точку по полю( как в паскале)
Как проинициализировать строковый тип данных 
strcpy(m1.name, "...")
struct item *p1 = &m1;
((*p1).cost = ...;)== (p1->cost = ...;)
одинаковые по значению(разыменовывание по указателю)

Можно присваивать структуры(здесь мы копируем данные из поля), можно (а значит нечто похожее на объекты первого сорта)
Есть нечто похожее на наследование(вложенные структуры)
из структур можно делать массивы
